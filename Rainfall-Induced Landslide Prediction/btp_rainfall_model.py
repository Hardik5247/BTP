# -*- coding: utf-8 -*-
"""BTP-Rainfall-Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1grm6HbOFx72K_bUFD27BNaa9qBPAK4Sc

## Setup
"""

import requests
import urllib.parse
import json
import time
import pandas as pd
import signal
import sys
import warnings

from pyproj import CRS, Transformer
from shapely.geometry import Point
from shapely.ops import transform

from math import isnan
from datetime import datetime, timedelta
from concurrent.futures import ProcessPoolExecutor, as_completed
pd.options.mode.chained_assignment = None  # default='warn'


def geodesic_point_buffer(lat, lon, meters, res):
  # Azimuthal equidistant projection
  aeqd_proj = CRS.from_proj4(
      f"+proj=aeqd +lat_0={lat} +lon_0={lon} +x_0=0 +y_0=0")
  tfmr = Transformer.from_proj(aeqd_proj, aeqd_proj.geodetic_crs)
  buf = Point(0, 0).buffer(distance=meters, resolution=res)
  return transform(tfmr.transform, buf).exterior.coords[:]


def send_request(i, coords):
  x = [f"{lat},{lon}" for lon, lat in coords]
  length = len(x)
  start = 0
  increment = 100 # max locations at a time, setup own server and set this to 10000
  results = []
  print(i + 2)
  while start < length:
    curr = x[start : min(start + increment, length)]
    locations = "|".join(curr)
    
    # https://api.opentopodata.org/v1/srtm30m http://localhost:5000/v1/srtm30m headers={'User-Agent': 'Mozilla/5.0'}
    r = requests.post(url="https://api.opentopodata.org/v1/srtm30m", json={'locations': locations, "nodata_value": "-9999"}, headers={"Connection": "close"})
    print(i + 2, start)

    if r.status_code == 200:
      results.extend(r.json()['results'])
      start += increment
    elif r.status_code == 429:
      print("Sleeping for 1 second...", r.json())
      time.sleep(2)
    else:
      print("Error", r.status_code, r.json())
      start += increment
  print(i + 2, len(results))
  return [i, results]


date_format = '%Y-%m-%d'


def get_rainfall(lat, lon, start_date, end_date):
  url = 'https://archive-api.open-meteo.com/v1/archive'
  params = {
    'latitude': lat,
    'longitude': lon,
    'start_date': start_date.strftime(date_format),
    'end_date': end_date.strftime(date_format),
    'daily': 'rain_sum',
    'timezone': 'Asia/Kolkata'
  }
  return requests.get(url + '?' + urllib.parse.urlencode(params)).json()


def signal_handler(signal, frame):
  print(2)
  # df_rainfall.to_csv(, index=False)
  # [f.cancel() for f in futures]
  # Accessing protected member of a class here (could fail in future versions)
  try:
    """for pid, proc in executor._processes.items():
      if proc.is_alive():
        proc.terminate()
    executor.shutdown()"""
    pass
  except Exception as e:
    print(e)
  finally:
    sys.exit(0)


if __name__ == '__main__':
  warnings.filterwarnings("ignore", category=RuntimeWarning)
  signal.signal(signal.SIGINT, signal_handler)
  signal.signal(signal.SIGTERM, signal_handler)

  original_dataset_path = 'nasa_glc_india.csv'
  cleaned_dataset_path = 'nasa_glc_india_cleaned.csv'
  cleaned_dataset_with_rainfall_path = 'nasa_glc_india_cleaned_rainfall.csv'
  final_dataset = 'nasa_glc_india_final.csv'
  final_dataset_with_elevations = 'nasa_glc_india_final_elevation.csv'
  non_rainfall_induced = 'nasa_glc_non_rainfall_induced.csv'
  rainfall_data_path = 'landslide_rainfall_data.json'

  # df_rainfall = pd.read_csv()

  """length_transform = { 'exact': 0.03, '1km': 1.0, '5km': 5.0, '10km': 10.0 }

  if 'elevation_relief' not in df_rainfall:
    df_rainfall['elevation_relief'] = ''

  executor = ProcessPoolExecutor(max_workers=12)
  futures = []

  for i in range(len(df_rainfall['latitude'])):
    if not isnan(df_rainfall['elevation_relief'][i]):
      continue
    radius_meters = int(length_transform[df_rainfall['location_accuracy'][i]] * 1000)

    lat = df_rainfall['latitude'][i]
    lon = df_rainfall['longitude'][i]
    
    coords_within_circle = set([])
    for j in range(30, radius_meters + 1, 30):
      coords = set(geodesic_point_buffer(lat, lon,  j, (240 * j / 10000)))
      coords_within_circle = coords_within_circle.union(coords)
    
    try:
      future = executor.submit(send_request, i, coords_within_circle)
      futures.append(future)
    except Exception as e:
      print("Error:", e)
      continue

  
  try:
    for future in as_completed(futures):
      data = future.result()
      i = data[0]
      data = data[1]
      if len(data) > 0:
        elevations = [coord['elevation'] for coord in data if coord.get('elevation', None) not in {None, "-9999", -9999}]
        df_rainfall['elevation_relief'][i] = max(elevations) - min(elevations)
        print(f"Elevation relief {i + 2}:", df_rainfall['elevation_relief'][i])
        with open('outputs.txt', 'a') as output_file:
          output_file.write(f"Elevation_relief-{i}:{df_rainfall['elevation_relief'][i]}\n")
  finally:
    df_rainfall.to_csv(, index=False)
    print(1)
    [f.cancel() for f in futures]
    # Accessing protected member of a class here (could fail in future versions)
    for pid, proc in executor._processes.items():
      if proc.is_alive():
        proc.terminate()
    executor.shutdown()"""
